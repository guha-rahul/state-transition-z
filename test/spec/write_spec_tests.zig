const std = @import("std");
const ForkSeq = @import("config").ForkSeq;
const spec_test_options = @import("spec_test_options");
const RunnerKind = @import("./runner_kind.zig").RunnerKind;

const supported_forks = [_]ForkSeq{
    .phase0,
    .altair,
    .bellatrix,
    .capella,
    .deneb,
    .electra,
    .fulu,
};

const supported_test_runners = [_]RunnerKind{
    .merkle_proof,
    .operations,
    .rewards,
    .sanity,
    .epoch_processing,
    .fork,
    .transition,
    .random,
    .finality,
};

fn TestWriter(comptime kind: RunnerKind) type {
    return switch (kind) {
        .merkle_proof => @import("./writer/merkle_proof.zig"),
        .operations => @import("./writer/operations.zig"),
        .rewards => @import("./writer/rewards.zig"),
        .sanity => @import("./writer/sanity.zig"),
        .epoch_processing => @import("./writer/epoch_processing.zig"),
        .fork => @import("./writer/fork.zig"),
        .transition => @import("./writer/transition.zig"),
        .random => @import("./writer/random.zig"),
        .finality => @import("./writer/finality.zig"),
        else => @compileError("Unsupported test runner"),
    };
}

pub fn main() !void {
    const test_case_dir = "test/spec/test_case/";
    try std.fs.cwd().makePath(test_case_dir);

    inline for (supported_test_runners) |kind| {
        const test_case_file = test_case_dir ++ @tagName(kind) ++ "_tests.zig";
        const out = try std.fs.cwd().createFile(test_case_file, .{});
        defer out.close();

        const writer = out.writer().any();
        try writeTests(&supported_forks, kind, writer);
    }

    {
        const test_root_file = "test/spec/root.zig";
        try std.fs.cwd().makePath("test/spec");
        const out = try std.fs.cwd().createFile(test_root_file, .{});
        defer out.close();
        const writer = out.writer().any();
        try writeTestRoot(&supported_test_runners, writer);
    }
}

pub fn writeTestRoot(comptime kinds: []const RunnerKind, writer: std.io.AnyWriter) !void {
    try writer.print(
        \\// This file is generated by write_spec_tests.zig.
        \\// Do not commit changes by hand.
        \\
        \\const testing = @import("std").testing;
        \\
        \\comptime {{
        \\
    , .{});
    inline for (kinds) |kind| {
        try writer.print(
            \\    testing.refAllDecls(@import("./test_case/{s}_tests.zig"));
            \\
        , .{@tagName(kind)});
    }
    try writer.print(
        \\}}
        \\
    , .{});
}

pub fn writeTests(
    comptime forks: []const ForkSeq,
    comptime kind: RunnerKind,
    writer: std.io.AnyWriter,
) !void {
    try TestWriter(kind).writeHeader(writer);

    var root_dir = try std.fs.cwd().openDir(spec_test_options.spec_test_out_dir ++ "/" ++ spec_test_options.spec_test_version, .{});
    defer root_dir.close();

    // minimal preset includes many more testcases and is a superset of mainnet testcases
    var preset_dir = try root_dir.openDir("minimal/tests/minimal", .{});
    defer preset_dir.close();

    inline for (forks) |fork| {
        const fork_path = @tagName(fork) ++ "/" ++ @tagName(kind);
        const maybe_fork_dir = preset_dir.openDir(fork_path, .{ .iterate = true }) catch |err| switch (err) {
            error.FileNotFound => null,
            else => return err,
        };

        if (maybe_fork_dir) |dir| {
            var fork_dir = dir;
            defer fork_dir.close();

            inline for (TestWriter(kind).handlers) |handler| handler_loop: {
                var suite_dir = fork_dir.openDir(comptime handler.suiteName(), .{ .iterate = true }) catch |err| switch (err) {
                    error.FileNotFound => break :handler_loop,
                    else => return err,
                };
                defer suite_dir.close();

                var suite_iter = suite_dir.iterate();
                while (try suite_iter.next()) |suite_entry| {
                    if (suite_entry.kind != .directory) continue;

                    if (comptime kind.hasSuiteCase()) {
                        var case_dir = suite_dir.openDir(suite_entry.name, .{ .iterate = true }) catch continue;
                        defer case_dir.close();

                        var case_iter = case_dir.iterate();
                        while (try case_iter.next()) |case_entry| {
                            if (case_entry.kind != .directory) continue;
                            try TestWriter(kind).writeTest(writer, fork, handler, suite_entry.name, case_entry.name);
                        }
                    } else {
                        try TestWriter(kind).writeTest(writer, fork, handler, suite_entry.name);
                    }
                }
            }
        }
    }
}
