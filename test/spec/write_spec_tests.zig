const std = @import("std");
const ForkSeq = @import("config").ForkSeq;
const spec_test_options = @import("spec_test_options");
const RunnerKind = @import("./runner_kind.zig").RunnerKind;

const supported_forks = [_]ForkSeq{
    .phase0,
    .altair,
    .bellatrix,
    .capella,
    .deneb,
    .electra,
};

const supported_test_runners = [_]RunnerKind{
    .operations,
    .sanity,
    .epoch_processing,
};

fn TestWriter(comptime kind: RunnerKind) type {
    return switch (kind) {
        .operations => @import("./writer/operations.zig"),
        .sanity => @import("./writer/sanity.zig"),
        .epoch_processing => @import("./writer/epoch_processing.zig"),
        else => @compileError("Unsupported test runner"),
    };
}

pub fn main() !void {
    const test_case_dir = "test/spec/test_case/";
    std.fs.cwd().makeDir(test_case_dir) catch |err| {
        if (err != error.PathAlreadyExists) return err;
        // ignore if the directory already exists
    };

    inline for (supported_test_runners) |kind| {
        const test_case_file = test_case_dir ++ @tagName(kind) ++ "_tests.zig";
        const out = try std.fs.cwd().createFile(test_case_file, .{});
        defer out.close();

        const writer = out.writer().any();
        try writeTests(&supported_forks, kind, writer);
    }

    {
        const test_root_file = "test/spec/root.zig";
        const out = try std.fs.cwd().createFile(test_root_file, .{});
        defer out.close();
        const writer = out.writer().any();
        try writeTestRoot(&supported_test_runners, writer);
    }
}

pub fn writeTestRoot(comptime kinds: []const RunnerKind, writer: std.io.AnyWriter) !void {
    try writer.print(
        \\// This file is generated by write_spec_tests.zig.
        \\// Do not commit changes by hand.
        \\
        \\const testing = @import("std").testing;
        \\
        \\comptime {{
        \\
    , .{});
    inline for (kinds) |kind| {
        try writer.print(
            \\    testing.refAllDecls(@import("./test_case/{s}_tests.zig"));
            \\
        , .{@tagName(kind)});
    }
    try writer.print(
        \\}}
        \\
    , .{});
}

pub fn writeTests(
    comptime forks: []const ForkSeq,
    comptime kind: RunnerKind,
    writer: std.io.AnyWriter,
) !void {
    try TestWriter(kind).writeHeader(writer);

    var root_dir = try std.fs.cwd().openDir(spec_test_options.spec_test_out_dir ++ "/" ++ spec_test_options.spec_test_version, .{});
    defer root_dir.close();

    // minimal preset includes many more testcases and is a superset of mainnet testcases
    var preset_dir = try root_dir.openDir("minimal/tests/minimal", .{});
    defer preset_dir.close();

    inline for (forks) |fork| {
        var fork_dir = try preset_dir.openDir(@tagName(fork) ++ "/" ++ @tagName(kind), .{});
        defer fork_dir.close();

        inline for (TestWriter(kind).handlers) |handler| {
            st: {
                var suite_dir = fork_dir.openDir(comptime handler.suiteName(), .{ .iterate = true }) catch break :st;
                defer suite_dir.close();

                var test_case_iterator = suite_dir.iterate();
                while (try test_case_iterator.next()) |test_case_entry| {
                    if (test_case_entry.kind != .directory) {
                        continue;
                    }
                    const test_case_name = test_case_entry.name;

                    try TestWriter(kind).writeTest(writer, fork, handler, test_case_name);
                }
            }
        }
    }
}
