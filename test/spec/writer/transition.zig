const std = @import("std");
const ForkSeq = @import("config").ForkSeq;

/// Transition has no sub-handlers so we define a single value enum.
pub const Handler = enum {
    Transition,

    pub fn suiteName(_: Handler) []const u8 {
        return "core/pyspec_tests";
    }
};

pub const handlers = std.enums.values(Handler);

pub const header =
    \\// This file is generated by write_spec_tests.zig.
    \\// Do not commit changes by hand.
    \\
    \\const std = @import("std");
    \\const ForkSeq = @import("config").ForkSeq;
    \\const active_preset = @import("preset").active_preset;
    \\const spec_test_options = @import("spec_test_options");
    \\const Transition = @import("../runner/transition.zig").Transition;
    \\
    \\const allocator = std.testing.allocator;
    \\
    \\
;

const test_template =
    \\test "{s} transition {s}" {{
    \\    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{{
    \\        spec_test_options.spec_test_out_dir,
    \\        spec_test_options.spec_test_version,
    \\        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/{s}/transition/{s}/{s}",
    \\    }});
    \\    defer allocator.free(test_dir_name);
    \\    const test_dir = std.fs.cwd().openDir(test_dir_name, .{{}}) catch return error.SkipZigTest;
    \\
    \\    {s}
    \\}}
    \\
    \\
;

pub fn writeHeader(writer: std.io.AnyWriter) !void {
    try writer.print(header, .{});
}

pub fn writeTest(
    writer: std.io.AnyWriter,
    fork: ForkSeq,
    handler: Handler,
    test_case_name: []const u8,
) !void {
    const execute_call = std.fmt.allocPrint(std.heap.page_allocator, "try Transition(.{s}).execute(allocator, test_dir);", .{@tagName(fork)}) catch unreachable;
    defer std.heap.page_allocator.free(execute_call);
    try writer.print(test_template, .{
        @tagName(fork),
        // skip handler
        test_case_name,

        @tagName(fork),
        handler.suiteName(),
        test_case_name,

        execute_call,
    });
}
