const std = @import("std");
const spec_test_options = @import("spec_test_options");
const ForkSeq = @import("config").ForkSeq;
const Preset = @import("preset").Preset;
const Handler = @import("../runner/sanity.zig").Handler;

pub const handlers = std.enums.values(Handler);

pub const header =
    \\// This file is generated by write_spec_tests.zig.
    \\// Do not commit changes by hand.
    \\
    \\const std = @import("std");
    \\const Node = @import("persistent_merkle_tree").Node;
    \\const ForkSeq = @import("config").ForkSeq;
    \\const active_preset = @import("preset").active_preset;
    \\const spec_test_options = @import("spec_test_options");
    \\const Sanity = @import("../runner/sanity.zig");
    \\
    \\const allocator = std.testing.allocator;
    \\const pool_size = if (active_preset == .mainnet) 10_000_000 else 1_000_000;
    \\
;

const test_template =
    \\test "{s} sanity {s} {s}" {{
    \\    var pool = try Node.Pool.init(allocator, pool_size);
    \\    defer pool.deinit();
    \\    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{{
    \\        spec_test_options.spec_test_out_dir,
    \\        spec_test_options.spec_test_version,
    \\        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/{s}/sanity/{s}/pyspec_tests/{s}",
    \\    }});
    \\    defer allocator.free(test_dir_name);
    \\    const test_dir = std.fs.cwd().openDir(test_dir_name, .{{}}) catch return error.SkipZigTest;
    \\
    \\    {s}
    \\}}
    \\
    \\
;

pub fn writeHeader(writer: std.io.AnyWriter) !void {
    try writer.print(header, .{});
}

pub fn writeTest(
    writer: std.io.AnyWriter,
    fork: ForkSeq,
    handler: Handler,
    test_case_name: []const u8,
) !void {
    const execute_call = switch (handler) {
        .slots => std.fmt.allocPrint(std.heap.page_allocator, "try Sanity.SlotsTestCase(.{s}).execute(allocator, &pool, test_dir);", .{@tagName(fork)}) catch unreachable,
        .blocks => std.fmt.allocPrint(std.heap.page_allocator, "try Sanity.BlocksTestCase(.{s}).execute(allocator, &pool, test_dir);", .{@tagName(fork)}) catch unreachable,
    };
    defer std.heap.page_allocator.free(execute_call);
    try writer.print(test_template, .{
        @tagName(fork),
        @tagName(handler),
        test_case_name,

        @tagName(fork),
        @tagName(handler),
        test_case_name,

        execute_call,
    });
}
